import { ClientStorage } from "@/lib/storage";
import { composeStorageKey } from "@/modules";
import { minify as minifyHTMLString, Options } from "html-minifier-terser";

export interface HTMLMinifierServiceInit {
  minifyHTML: typeof minifyHTMLString;
  optionStorage: ClientStorage<HTMLMinifyOptions>;
  historyStorage: ClientStorage<HTMLMinifyHistory>;
}

export interface HTMLMinifyOptions extends Options {}

export interface HTMLMinifyHistoryItem {
  originalHTML: string;
  minifiedHTML: string;
}

export type HTMLMinifyHistory = HTMLMinifyHistoryItem[];

const historyMaxLength = 1;

export class HTMLMinifierService {
  private minifyHTML: typeof minifyHTMLString;
  private optionStorage: ClientStorage<HTMLMinifyOptions>;
  private historyStorage: ClientStorage<HTMLMinifyHistory>;

  constructor({
    minifyHTML,
    optionStorage,
    historyStorage,
  }: HTMLMinifierServiceInit) {
    this.minifyHTML = minifyHTML;
    this.optionStorage = optionStorage;
    this.historyStorage = historyStorage;
  }

  static async build(): Promise<HTMLMinifierService> {
    const htmlMinifier = await import(
      //@ts-ignore
      "html-minifier-terser/dist/htmlminifier.esm.bundle"
    );
    return new HTMLMinifierService({
      minifyHTML: htmlMinifier.minify,
      historyStorage: new ClientStorage<HTMLMinifyHistory>({
        key: composeStorageKey("html-minifier-history"),
        defaultValue: [],
        beforeUpdate: (history) => history.slice(0, historyMaxLength),
      }),
      optionStorage: new ClientStorage<HTMLMinifyOptions>({
        key: composeStorageKey("html-minifier-options"),
        defaultValue: {
          continueOnParseError: false,
          caseSensitive: false,
          collapseBooleanAttributes: true,
          collapseInlineTagWhitespace: false,
          collapseWhitespace: true,
          conservativeCollapse: false,
          decodeEntities: true,
          html5: true,
          includeAutoGeneratedTags: false,
          keepClosingSlash: false,
          maxLineLength: undefined,
          minifyCSS: true,
          minifyJS: true,
          minifyURLs: false,
          noNewlinesBeforeTagClose: false,
          preserveLineBreaks: false,
          preventAttributesEscaping: false,
          processConditionalComments: true,
          processScripts: undefined,
          quoteCharacter: '"',
          removeAttributeQuotes: false,
          removeComments: true,
          removeEmptyAttributes: true,
          removeEmptyElements: false,
          removeOptionalTags: true,
          removeRedundantAttributes: true,
          removeScriptTypeAttributes: true,
          removeStyleLinkTypeAttributes: true,
          removeTagWhitespace: true,
          sortAttributes: true,
          sortClassName: true,
          trimCustomFragments: true,
          useShortDoctype: true,
        },
      }),
    });
  }

  async minify(html: string, options: HTMLMinifyOptions) {
    const minified = await this.minifyHTML(html, options);
    this.addHistory({
      originalHTML: html,
      minifiedHTML: minified,
    });
    return await this.minifyHTML(html, options);
  }

  addHistory(item: HTMLMinifyHistoryItem) {
    this.historyStorage.update([item, ...this.historyStorage.get()]);
  }

  getHistory() {
    return this.historyStorage.get();
  }

  getOptions() {
    return this.optionStorage.get();
  }

  updateOptions(options: HTMLMinifyOptions) {
    this.optionStorage.update(options);
  }
}
